# 코드1 
- 결과: 7%에서 시간초과
- DFS를 사용했습니다.
- 코드
```python3
import sys
sys.setrecursionlimit(10**6)

#M: 세로(행), N:가로(열) 
M,N=map(int, sys.stdin.readline().split())
maps=[ list(map(int, sys.stdin.readline().split())) for _ in range(M)]
visited=[ [False]*N for _ in range(M)] #방문리스트
cnt=0

dy=[-1,1,0,0]
dx=[0,0,-1,1]

def isRange(y,x):
    global N,M
    if(y>=0 and y<M) and(x>=0 and x<N):
        return True
    return False

def dfs(y,x):
    global visited, cnt, maps
     
    #아직 방문하지 않은 상태인가?
    if not visited[y][x]:
        print('\nnow-y: {0}, now-x: {1}'.format(y,x))
        #현위치가 (M-1, N-1)인가?
        if (y==M-1) and (x==N-1):
            cnt+=1
            print('now-cnt: ', cnt)
            

        visited[y][x]=True
        now=maps[y][x]
        
        #상/하/좌/우를 살펴보고
        #현위치의 값보다 작은곳으로 이동.
        for i in range(4):
            nexty= y+dy[i]
            nextx= x+dx[i]

            #적절한위치?
            if isRange(nexty, nextx):
                #아직방문하지 않은 상태이고, 현위치값보다 작은경우라면
                if (maps[nexty][nextx]<now) and (not visited[nexty][nextx]):
                    dfs(nexty, nextx)
        #더이상 상하좌우에 움직일수 없다면 -> backtracking한다.
        visited[y][x]=False

def main():
    global maps, M,N
    dfs(0,0)
    print(cnt)

if __name__=='__main__':
    main()

```

<hr>

# 코드2
- 결과:
- 코드
```python3
```
