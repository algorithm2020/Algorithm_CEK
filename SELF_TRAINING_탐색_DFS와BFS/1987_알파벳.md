# 코드1 (틀렸습니다)
- pypy3
- 그냥 전형적인 dfs방법을 이용했다.
- 보완점
  - 먼저 오른쪽 쭉간다 (현위치의 오른쪽 알파벳과 현위치의 알파벳이 서로달라야한다)
  - 더이상 오른쪽으로 갈수 없다면 아래로 내려간다
  - 왼쪽으로 가야한다.
- 코드
```python3
# -*- coding: utf-8 -*-
import sys
R,C=0,0
board=None
visited=None
unique_alpha=None
dy=[-1, 1, 0, 0]
dx=[0,0, -1, 1]

#R행*C열에 적절한 행렬인가?
def isRange(y,x):
    global R,C
    if (y>=0 and y<R) and (x>=0 and x<C):
        return True
    return False

def isUnique(y,x):
    global unique_alpha, board
    now_alpha= board[y][x]
    #이미 들어있다면.-> False 출력
    if now_alpha in unique_alpha:
        return False
    return True

def dfs(y,x):
    global visited, unique_alpha, board
    
    #방문을 아직 안한 상태인가?
    #현재알파벳이 unique_alpha 리스트에 없는가?
    if (not visited[y][x]) and (isUnique(y,x)):
        visited[y][x]=True
        now=board[y][x]
        unique_alpha.append(now)

        #근처 상/하/좌/우 알파벳확인.
        for i in range(4):
            nexty= y+dy[i]
            nextx= x+dx[i]
            #근처 알파벳이 적절한 위치에 있는가?
            if isRange(nexty, nextx):
                #근처알파벳이 now와 다르고
                #아직 방문하지 않은 상태인가?
                if (not visited[nexty][nextx]) and (board[nexty][nextx]!=now):
                    dfs(nexty, nextx)

def main():
    global R,C, board, visited, unique_alpha
    board=[] #board초기화
    R,C= map(int, sys.stdin.readline().split()) #R: 행(세로), C:열(가로)
    for _ in range(R):#board에 원소 넣기
        board.append(list(sys.stdin.readline().strip()))
    visited=[ [False]*C for _ in range(R)] #방문리스트 초기화
    unique_alpha=[]#단일 알파벳 초기화
    dfs(0,0)
    print(len(unique_alpha))

if __name__=='__main__':
    main()

```
